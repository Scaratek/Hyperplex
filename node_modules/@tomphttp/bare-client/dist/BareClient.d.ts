export * from './Client';
export declare type BareMethod = 'GET' | 'POST' | 'DELETE' | 'OPTIONS' | 'PUT' | 'PATCH' | 'UPDATE' | string;
export declare type BareCache = 'default' | 'no-store' | 'reload' | 'no-cache' | 'force-cache' | 'only-if-cached' | string;
export interface XBare {
    status?: number;
    statusText?: string;
    headers?: Headers;
    rawHeaders?: BareHeaders;
}
export declare type BareHTTPProtocol = 'blob:' | 'http:' | 'https:' | string;
export declare type BareWSProtocol = 'ws:' | 'wss:' | string;
export declare type urlLike = URL | string;
export declare const maxRedirects = 20;
export declare type BareHeaders = {
    [key: string]: string | string[];
};
/**
 * WebSocket with an additional property.
 */
export declare type BareWebSocket = WebSocket & {
    meta: Promise<XBare>;
};
/**
 * A Response with additional properties.
 */
export declare type BareResponse = Response & {
    rawResponse: Response;
    rawHeaders: BareHeaders;
};
/**
 * A BareResponse with additional properties.
 */
export declare type BareResponseFetch = BareResponse & {
    finalURL: string;
};
export declare type BareBodyInit = Blob | BufferSource | FormData | URLSearchParams | ReadableStream | undefined | null;
export declare type BareFetchInit = {
    method?: BareMethod;
    headers?: Headers | BareHeaders;
    body?: BareBodyInit;
    cache?: BareCache;
    redirect?: 'follow' | 'manual' | 'error' | string;
    signal?: AbortSignal;
};
export declare type BareMaintainer = {
    email?: string;
    website?: string;
};
export declare type BareProject = {
    name?: string;
    description?: string;
    email?: string;
    website?: string;
    repository?: string;
    version?: string;
};
export declare type BareLanguage = 'NodeJS' | 'ServiceWorker' | 'Deno' | 'Java' | 'PHP' | 'Rust' | 'C' | 'C++' | 'C#' | 'Ruby' | 'Go' | 'Crystal' | 'Shell' | string;
export declare type BareManifest = {
    maintainer?: BareMaintainer;
    project?: BareProject;
    versions: string[];
    language: BareLanguage;
    memoryUsage?: number;
};
export default class BareClient {
    /**
     * @depricated Use .manifest instead.
     */
    get data(): BareClient['manfiest'];
    manfiest?: BareManifest;
    private client?;
    private server;
    private working?;
    private onDemand;
    private onDemandSignal?;
    /**
     * Lazily create a BareClient. Calls to fetch and connect will request the manifest once on-demand.
     * @param server A full URL to the bare server.
     * @param signal An abort signal for fetching the manifest on demand.
     */
    constructor(server: string | URL, signal?: AbortSignal);
    /**
     * Immediately create a BareClient.
     * @param server A full URL to the bare server.
     * @param manfiest A Bare server manifest.
     */
    constructor(server: string | URL, manfiest?: BareManifest);
    private demand;
    private getClient;
    request(method: BareMethod, requestHeaders: BareHeaders, body: BareBodyInit, protocol: BareHTTPProtocol, host: string, port: string | number, path: string, cache: BareCache | undefined, signal: AbortSignal | undefined): Promise<BareResponse>;
    connect(requestHeaders: BareHeaders, protocol: BareWSProtocol, host: string, port: string | number, path: string): Promise<BareWebSocket>;
    /**
     *
     * @param url
     * @param headers
     * @param protocols
     * @returns
     */
    createWebSocket(url: urlLike, headers?: BareHeaders | Headers, protocols?: string | string[]): Promise<BareWebSocket>;
    fetch(url: urlLike | Request, init?: BareFetchInit): Promise<BareResponseFetch>;
}
/**
 *
 * Facilitates fetching the Bare server and constructing a BareClient.
 * @param server Bare server
 * @param signal Abort signal when fetching the manifest
 */
export declare function createBareClient(server: string | URL, signal?: AbortSignal): Promise<BareClient>;
